#include <efi.h>
#include <csmwrap.h>

#include <io.h>
#include <x86thunk.h>
#include <video.h>

// Generated by: xxd -i Csm16.bin >> Csm16.h
#include <bins/Csm16.h>


#ifndef BUILD_VERSION
#define BUILD_VERSION "Unknown"
#endif

const char *banner = "CSMWrap Version " BUILD_VERSION "\n"
                     "https://github.com/flygoat/csmwrap\n"
                     "By: Jiaxun Yang <jiaxun.yang@flygoat.com>\n";

EFI_SYSTEM_TABLE *gST;
EFI_BOOT_SERVICES *gBS;
EFI_RUNTIME_SERVICES *gRT;
EFI_TIME gTimeAtBoot;

struct csmwrap_priv priv = {
    .csm_bin = Csm16_bin,
};

static void *find_table(uint32_t signature, uint8_t *csm_bin_base, size_t size)
{
    bool Done;
    uint8_t *Ptr;
    void *Table;

    Done  = FALSE;
    Table = NULL;
    for (Ptr = csm_bin_base; Ptr < (csm_bin_base + size) && !Done; Ptr += 0x10) {
        if (*(uint32_t *)Ptr == signature) {
            Table  = Ptr;
            // FIXME: Get checksum?
            Done = TRUE;
        }
    }

    return Table;
}

int set_smbios_table()
{
    EFI_GUID smbiosGuid = SMBIOS_TABLE_GUID;
    EFI_GUID smbios3Guid = SMBIOS3_TABLE_GUID;
    uintptr_t table_addr = 0;

    for (size_t i = 0; i < gST->NumberOfTableEntries; i++) {
        EFI_CONFIGURATION_TABLE *table = gST->ConfigurationTable + i;

        if (!efi_guidcmp(table->VendorGuid, smbiosGuid)) {
            printf("Found SMBIOS Table at %x\n", (uintptr_t)table->VendorTable);
            if (table_addr < 0x100000000) {
                table_addr = (uintptr_t)table->VendorTable;
            }
            break;
        }
    }

    if (table_addr == 0) {
        for (size_t i = 0; i < gST->NumberOfTableEntries; i++) {
            EFI_CONFIGURATION_TABLE *table = gST->ConfigurationTable + i;

            if (!efi_guidcmp(table->VendorGuid, smbios3Guid)) {
                printf("Found SMBIOS 3.0 Table at %x\n", (uintptr_t)table->VendorTable);
                if (table_addr < 0x100000000) {
                    table_addr = (uintptr_t)table->VendorTable;
                }
                break;
            }
        }
    }

    if (table_addr != 0) {
        priv.low_stub->boot_table.SmbiosTable = table_addr;
        return 0;
    }

    printf("No usable SMBIOS table found\n");

    return -1;
}

EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_PHYSICAL_ADDRESS HiPmm;
    uintptr_t csm_bin_base;
    EFI_STATUS Status;
    EFI_IA32_REGISTER_SET Regs;

    gST = SystemTable;
    gBS = SystemTable->BootServices;
    gRT = SystemTable->RuntimeServices;

    printf("%s", banner);

    for (uintptr_t i = 0; i < 0x100000; i += EFI_PAGE_SIZE) {
        uintptr_t j = i;
        if (gBS->AllocatePages(AllocateAddress, EfiLoaderData, 1, &j) != EFI_SUCCESS) {
            if (i < 0xa0000) {
                printf("warning: Early AllocatePages() failed for address %p\n", i);
            }
        }
    }

    if (gRT->GetTime(&gTimeAtBoot, NULL) != EFI_SUCCESS) {
        printf("Failed to query current time\n");
        return -1;
    }

    gBS->SetWatchdogTimer(0, 0, 0, NULL);

    if (unlock_bios_region()) {
        printf("Unable to unlock BIOS region\n");
        return -1;
    }
    printf("Unlock!\n");

    apply_intel_platform_workarounds();

    csm_bin_base = (uintptr_t)BIOSROM_END - sizeof(Csm16_bin);
    priv.csm_bin_base = csm_bin_base;
    printf("csm_bin_base: 0x%lx\n", csm_bin_base);
    if (csm_bin_base < VGABIOS_END) {
        printf("Illegal csm_bin size \n");
        return -1;
    }

    priv.csm_efi_table = find_table(EFI_COMPATIBILITY16_TABLE_SIGNATURE, Csm16_bin, sizeof(Csm16_bin));
    if (priv.csm_efi_table == NULL) {
        printf("EFI_COMPATIBILITY16_TABLE not found\n");
        return -1;
    }

    acpi_init(&priv);

    Status = csmwrap_video_init(&priv);

    HiPmm = 0xffffffff;
    if (gBS->AllocatePages(AllocateMaxAddress, EfiRuntimeServicesData, HIPMM_SIZE / EFI_PAGE_SIZE, &HiPmm) != EFI_SUCCESS) {
        printf("Unable to alloc HiPmm!!!\n");
        return -1;
    }

    priv.low_stub = (struct low_stub *)LOW_STUB_BASE;
    memset((void*)LOW_STUB_BASE, 0, CONVEN_END - LOW_STUB_BASE);

    set_smbios_table();
    priv.low_stub->boot_table.AcpiTable = priv.csm_efi_table->AcpiRsdPtrPointer;

    uintptr_t pmm_base = LegacyBiosInitializeThunkAndTable(LOW_STUB_BASE, sizeof(struct low_stub));

    printf("Init Thunk pmm: %lx\n", (uintptr_t)pmm_base);

    priv.low_stub->init_table.BiosLessThan1MB = 0x00080000; // Whole EBDA
    priv.low_stub->init_table.ThunkStart = (uint32_t)(uintptr_t)priv.low_stub;
    priv.low_stub->init_table.ThunkSizeInBytes = sizeof(struct low_stub);
    priv.low_stub->init_table.LowPmmMemory = (uint32_t)pmm_base;
    priv.low_stub->init_table.LowPmmMemorySizeInBytes = (uint32_t)CONVEN_END - (uint32_t)pmm_base;
    priv.low_stub->init_table.HiPmmMemorySizeInBytes = HIPMM_SIZE;
    priv.low_stub->init_table.HiPmmMemory = HiPmm;

    priv.low_stub->vga_oprom_table.OpromSegment = EFI_SEGMENT(VGABIOS_START);
    priv.low_stub->vga_oprom_table.PciBus = priv.vga_pci_bus;
    priv.low_stub->vga_oprom_table.PciDeviceFunction = priv.vga_pci_devfn;

    build_coreboot_table(&priv);

    printf("CALL16 %x:%x\n", priv.csm_efi_table->Compatibility16CallSegment,
            priv.csm_efi_table->Compatibility16CallOffset);

    /* WARNING: No EFI Video afterwards */
    csmwrap_video_prepare_exitbs(&priv);
    acpi_prepare_exitbs();

    /* WARNING: No EFI runtime service afterwards */
    UINTN efi_mmap_size = 0, efi_desc_size = 0, efi_mmap_key = 0;
    UINT32 efi_desc_ver = 0;
    EFI_MEMORY_DESCRIPTOR *efi_mmap;
    EFI_MEMORY_DESCRIPTOR tmp_mmap[1];
    efi_mmap_size = sizeof(tmp_mmap);
    gBS->GetMemoryMap(&efi_mmap_size, tmp_mmap, &efi_mmap_key, &efi_desc_size, &efi_desc_ver);
    efi_mmap_size += 4096;
    Status = gBS->AllocatePool(EfiLoaderData, efi_mmap_size, (void **)&efi_mmap);
    if (Status != EFI_SUCCESS) {
        printf("AllocatePool() for EFI memory map failed!");
        return -1;
    }
    Status = gBS->GetMemoryMap(&efi_mmap_size, efi_mmap, &efi_mmap_key, &efi_desc_size, &efi_desc_ver);
    if (Status != EFI_SUCCESS) {
        printf("GetMemoryMap() failed!");
        return -1;
    }

    // It may take N amounts of ExitBootServices() calls to complete...
    // Cap at 128.
    for (size_t i = 0; i < 128; i++) {
        Status = gBS->ExitBootServices(ImageHandle, efi_mmap_key);
        if (Status == EFI_SUCCESS) {
            break;
        }
    }
    if (Status != EFI_SUCCESS) {
        printf("Failed to exit boot services!");
        return -1;
    }

    /* Disable external interrupts */
    asm volatile ("cli");

    build_e820_map(&priv, efi_mmap, efi_mmap_size, efi_desc_size);
    uintptr_t e820_low = (uintptr_t)&priv.low_stub->e820_map;
    priv.csm_efi_table->E820Pointer = e820_low;
    priv.csm_efi_table->E820Length = sizeof(EFI_E820_ENTRY64) * priv.low_stub->e820_entries;

    /* Disable 8259 PIC */
    outb(0x21, 0xff);
    outb(0xa1, 0xff);
    outb(0x43, 0x36);
    /* Program PIT to default */
    outb(0x40, 0x00);
    outb(0x40, 0x00);

    /* Copy ROM to location, as late as possible */
    memcpy((void*)csm_bin_base, Csm16_bin, sizeof(Csm16_bin));
    memcpy((void*)VGABIOS_START, vbios_loc, vbios_size);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16InitializeYourself;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->init_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->init_table);

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16DispatchOprom;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->vga_oprom_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->vga_oprom_table);
    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16PrepareToBoot;
    Regs.X.ES = EFI_SEGMENT(&priv.low_stub->boot_table);
    Regs.X.BX = EFI_OFFSET(&priv.low_stub->boot_table);

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    memset(&Regs, 0, sizeof(EFI_IA32_REGISTER_SET));
    Regs.X.AX = Legacy16Boot;
    // No arguments?

    LegacyBiosFarCall86(priv.csm_efi_table->Compatibility16CallSegment,
                        priv.csm_efi_table->Compatibility16CallOffset,
                        &Regs,
                        NULL,
                        0);

    return 0;
}
